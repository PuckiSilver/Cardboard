from zipfile import ZipFile
import yaml
import json
import shutil
import sys
from time import sleep

def get_config() -> dict:
    config = {}

    path = sys.argv[2] if len(sys.argv) > 2 else input('Provide a the path to a yml/yaml config file or press return\n')
    if path:
        path = path.replace('"','').replace("'",'')
        with open(path) as stream:
            try: return yaml.safe_load(stream)
            except: close_with_error('Coudn\'t read config at ' + path)
    
    config['name'] =        input('Human readable name [Filename]: ')
    config['id'] =          input('Id [Filename with limited charset]: ')
    config['description'] = input('Description [Description in pack.mcmeta]: ')
    config['version'] =     input('Version [1.0.0]: ') or '1.0.0'
    config['authors'] =     input('Authors (separate multiple using commas) [empty]: ')
    config['license'] =     input('License [All rights reserved]: ')
    config['homepage'] =    input('Homepage/Projectpage [empty]: ')
    config['issues'] =      input('Issuetracker [empty]: ')
    config['sources'] =     input('Sources [empty]: ')
    print()

    return config

def get_fabric_mod_json(config:dict) -> str:
    dictionary = {}
    dictionary['schemaVersion'] = 1
    dictionary['id'] = config['id']
    dictionary['version'] = config['version']

    if config.get('name'): dictionary['name'] = config['name']
    if config.get('description'): dictionary['description'] = config['description']
    if config.get('license'): dictionary['license'] = config['license']
    if config.get('icon'): dictionary['icon'] = config['icon']

    if config.get('homepage') or config.get('issues') or config.get('sources'):
        dictionary['contact'] = {}
    if config.get('homepage'): dictionary['contact']['homepage'] = config['homepage']
    if config.get('issues'): dictionary['contact']['issues'] = config['issues']
    if config.get('sources'): dictionary['contact']['sources'] = config['sources']

    if config.get('authors'): dictionary['authors'] = [a.strip() for a in config['authors'].split(',')]

    dictionary['depends'] = {'fabric-resource-loader-v0': '*'}

    return json.dumps(dictionary)

def get_quilt_mod_json(config:dict) -> str:
    dictionary = {}
    data = {}
    metadata = {}
    dictionary['schemaVersion'] = 1
    dictionary['quilt_loader'] = data

    data['group'] = 'com.github.puckisilver'
    data['id'] = config['id']
    data['version'] = config['version']
    data['metadata'] = metadata

    if config.get('name'): metadata['name'] = config['name']
    if config.get('description'): metadata['description'] = config['description']
    if config.get('license'): metadata['license'] = config['license']
    if config.get('icon'): metadata['icon'] = config['icon']

    if config.get('homepage') or config.get('issues') or config.get('sources'):
        metadata['contact'] = {}
    if config.get('homepage'): metadata['contact']['homepage'] = config['homepage']
    if config.get('issues'): metadata['contact']['issues'] = config['issues']
    if config.get('sources'): metadata['contact']['sources'] = config['sources']

    if config.get('authors'): dictionary['contributors'] = {
        a.strip(): 'Owner' if idx == 0 else 'Developer'
        for idx, a in enumerate(config['authors'].split(','))}
    
    data['depends'] = [{'id':'quilt_resource_loader','versions':'*','unless':'fabric-resource-loader-v0'}]

    return json.dumps(dictionary)

def get_forge_mods_toml(config:dict) -> str:
    toml = [
        'modLoader="lowcodefml"',
        'loaderVersion="[1,)"',
        f'license="{config.get("license") or "All rights reserved"}"',
    ]
    if config.get('issues'): toml.append(f'issueTrackerURL="{config["issues"]}"')
    toml.extend(['[[mods]]', f'    modId="{config["id"]}"'])
    if config.get('version'):       toml.append(f'    version="{    config["version"]}"')
    if config.get('name'):          toml.append(f'    displayName="{config["name"]}"')
    if config.get('description'):   toml.append(f'    description="{config["description"]}"')
    if config.get('icon'):          toml.append(f'    logoFile="{   config["icon"]}"')
    if config.get('authors'):       toml.append(f'    authors="{    config["authors"]}"')
    if config.get('homepage'):      toml.append(f'    displayURL="{ config["homepage"]}"')
    toml.append('    displayTest="NONE"')
    toml.append('    credits="Generated by https://github.com/PuckiSilver/Cardboard"')
    return '\n'.join(toml)

def close_with_error(error:str):
    print(error)
    sleep(2)
    quit()

def main():
    if len(sys.argv) < 2: close_with_error("Please drag the zipped data pack onto this file")
    zip_path = sys.argv[1]
    if not zip_path.endswith('.zip'): close_with_error("This only works for zipped data packs")

    config = get_config()
    with ZipFile(zip_path, 'r') as pack:
        try: config['icon'] = 'pack.png' if pack.getinfo('pack.png') else ''
        except: config['icon'] = ''
        
        if not config.get('description'):
            with pack.open('pack.mcmeta') as mcmeta:
                mcmeta = mcmeta.read().decode()
                if (desc_start := mcmeta.find('"description"')) == -1: close_with_error('Can\'t find a description in pack.mcmeta')
                description = mcmeta[desc_start+13:]
                start = description.find('"')
                config['description'] = description[start+1:description.find('"', start+1)]
        pack.close()
    
    if not config.get('name'):
        (start := zip_path.rfind('/')) != -1 or (start := zip_path.rfind('\\'))
        if start == -1: close_with_error('Can\'t extract filename')
        config['name'] = zip_path[start+1:-4]

    if not config.get('id'):
        allowed = 'abcdefghijklmnopqrstuvwxyz0123456789_'
        config['id'] = ''.join([
            c if c in allowed else ''
            for c in config['name'].replace(' ','_').replace('-','_').lower()])
    
    if not config.get('version'): config['version'] = '1.0.0'

    jar_path = zip_path[:-4] + '.jar'
    shutil.copyfile(zip_path, jar_path)

    with ZipFile(jar_path, 'a') as jar:
        jar.writestr('fabric.mod.json', get_fabric_mod_json(config))
        jar.writestr('quit.mod.json', get_quilt_mod_json(config))
        jar.writestr('META-INF/mods.toml', get_forge_mods_toml(config))
        jar.close()

if __name__ == '__main__':
    main()
